apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-conf
  namespace: {{ .Release.Namespace | quote }}
data:
  nginx.conf: |
    worker_processes 1;
    events {
        worker_connections  1024;
    }
    user root;

    http {
      server {
        listen 80;
        location / {
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          resolver 10.43.0.10;
          set $boots_dns {{ .Values.boots.name }}.{{ .Release.Namespace }}.svc.cluster.local; # needed in Kubernetes for dynamic DNS resolution

          proxy_pass http://$boots_dns;
        }
      }

      server {
        listen {{ .Values.hegel.deployment.port }};
        location / {
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          resolver 10.43.0.10;
          set $hegel_dns {{ .Values.hegel.name }}.{{ .Release.Namespace }}.svc.cluster.local; # needed in Kubernetes for dynamic DNS resolution

          proxy_pass http://$hegel_dns:50061;
        }
      }

      server {
        listen {{ .Values.tink.server.deployment.port }} http2;
        location / {
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          resolver 10.43.0.10;
          set $tink_dns {{ .Values.tink.server.name }}.{{ .Release.Namespace }}.svc.cluster.local; # needed in Kubernetes for dynamic DNS resolution

          grpc_pass grpc://$tink_dns:42113;
        }
      }

       server {
        listen {{ .Values.stack.hook.port }};
        location / {
          root /usr/share/nginx/html;
        }
      }
    }

    stream {
      log_format logger-json escape=json '{"source": "nginx", "time": $msec, "address": "$remote_addr", "status": $status, "upstream_addr": "$upstream_addr"}';

      server {
          listen 67 udp;
          resolver 10.43.0.10; # needed in Kubernetes for dynamic DNS resolution
          set $boots_dns {{ .Values.boots.name }}.{{ .Release.Namespace }}.svc.cluster.local; # needed in Kubernetes for dynamic DNS resolution
          proxy_pass $boots_dns:67;
          proxy_bind $remote_addr:$remote_port transparent;
          proxy_responses 0;
          access_log /dev/stdout logger-json;
      }
      server {
          listen 69 udp;
          resolver 10.43.0.10;
          set $boots_dns {{ .Values.boots.name }}.{{ .Release.Namespace }}.svc.cluster.local; # needed in Kubernetes for dynamic DNS resolution
          proxy_pass $boots_dns:69;
          proxy_timeout 1s;
          access_log /dev/stdout logger-json;
      }
      server {
          listen 514 udp;
          resolver 10.43.0.10;
          set $boots_dns {{ .Values.boots.name }}.{{ .Release.Namespace }}.svc.cluster.local; # needed in Kubernetes for dynamic DNS resolution
          proxy_pass $boots_dns:514;
          proxy_bind $remote_addr:$remote_port transparent;
          proxy_responses 0;
          access_log /dev/stdout logger-json;
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Values.stack.name}}
  namespace: {{ .Release.Namespace | quote }}
spec:
  selector:
    matchLabels:
      {{- with .Values.stack.selector }}
      {{- toYaml . | nindent 6 }}
      {{- end }}
  replicas: 1
  template:
    metadata:
      labels:
        {{- with .Values.stack.selector }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
    spec:
      containers:
      - name: {{ .Values.stack.name }}
        image: {{ .Values.stack.image }}
        ports:
        {{- range .Values.boots.ports }}
        - containerPort: {{ .port}}
          name: {{ .name }}
          protocol: {{ .protocol }}
        {{- end }}
        - containerPort: {{ .Values.hegel.deployment.port }}
          protocol: TCP
          name: {{ .Values.hegel.deployment.portName }}
        - containerPort: {{ .Values.tink.server.deployment.port }}
          protocol: TCP
          name: {{ .Values.tink.server.deployment.portName }}
        - containerPort: {{ .Values.stack.hook.port }}
          protocol: TCP
          name: hook-http
        resources:
          limits:
            cpu: 500m
            memory: 128Mi
          requests:
            cpu: 10m
            memory: 64Mi
        volumeMounts:
        - mountPath: /usr/share/nginx/html
          name: hook-artifacts
        - mountPath: /etc/nginx
          readOnly: true
          name: nginx-conf
      {{- if .Values.stack.hook.enabled }}
      initContainers:
      - name: init-hook-download
        image: {{ .Values.stack.hook.image }}
        command: ["/bin/sh", "-c"]
        args: # TODO(jacobweinstock): add checksum verification after download
        - rm -rf /usr/share/nginx/html/checksums.txt;
          touch /usr/share/nginx/html/checksums.txt;
          {{- range $index, $keys := .Values.stack.hook.downloads }}
          echo -e "{{ $keys.sha512sum.kernel }}" >> /usr/share/nginx/html/checksums.txt;
          echo -e "{{ $keys.sha512sum.initramfs }}" >> /usr/share/nginx/html/checksums.txt;
          (cd /usr/share/nginx/html/; sha512sum -c checksums.txt && exit 0);
          apt update; apt -y install wget;
          echo downloading HOOK...;
          wget -O /tmp/hook{{ $index }}.tar.gz {{ $keys.url }};
          tar -zxvf /tmp/hook{{ $index }}.tar.gz -C "/usr/share/nginx/html/";
          rm -rf /tmp/hook{{ $index }}.tar.gz;
          {{- end }}
        volumeMounts:
        - mountPath: /usr/share/nginx/html
          name: hook-artifacts
      {{- end }}
      volumes:
      - name: hook-artifacts
        hostPath:
          path: /opt/hook
          type: DirectoryOrCreate
      - name: nginx-conf
        configMap:
          name: nginx-conf
          items:
            - key: nginx.conf
              path: nginx.conf
